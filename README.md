   
Домашняя работа №5 по дисциплине  
«Цифровые двойники в электронике, радиотехнике и системах связи»  
 Создание проекта на Unity
 

Конспект по лекции №5
Движок Unity — универсальный движок для создания игр на любых устройствах. Многофункционален. При установке самого Unity HUB дополнительно устанавливается и Visual Studio, ничего делать не нужно. В этой лабораторной работе я научился создавать проекты на Unity с добавлением физических эффектов, а также описывать их действия на C#
Для комфортной работы на Unity нужно сочетать:
•	Game design:
•	Подходы к разработке игр
•	Основы игрового дизайна 
•	Дизайн игрового окружения 
•	Руководство игроком в играх 
•	Игровой баланс 
•	Разработку:
•	C#, ООП, Git, Js

Unity c Аl= наука наук
Unity позволяет делать не только игры, но и обучающие симуляторы, приложения экстренного реагирования (first-responder applications) и другие приложения, ориентированные на бизнес, которые разрабатывались с помощью Unity и должны были обеспечивать взаимодействие с двух. и трехмерным пространством.

Образовательные проекты на Unity
Unity в образовании
•	Создание интерактивных лабораторных работ;
•	Разработка виртуальных стендов;
•	Проведение виртуальных экспериментов;






Рефлексия 
1. Понимание масштаба и универсальности Unity.
Главным открытием для меня стало осознание, что Unity — это не просто игровой движок, а мощная универсальная платформа для создания самого разного контента. Лекция расширила мое восприятие: теперь я вижу, что с его помощью можно разрабатывать не только игры, но и серьезные бизнес-приложения, симуляторы для экстренных служб и, что особенно актуально для меня как студента, образовательные проекты. Понимание, что один инструмент может охватывать столько разных сфер, мотивирует глубже его изучать.
2. Освоение практических навыков.
Из лекции я вынес не только теорию, но и четкое практическое руководство к действию. Я узнал, что процесс установки (через Unity HUB с автоматической интеграцией Visual Studio) максимально упрощен, что позволяет сразу приступить к работе. Ключевым практическим итогом для меня стало осознание связи между визуальной частью (добавление объектов, настройка физики в редакторе) и программной (описание их поведения на C#). Это фундаментальный принцип работы в Unity, и я рад, что начал его осваивать.
3. Важность междисциплинарного подхода.
Лекция наглядно показала, что успешная работа в Unity требует сочетания двух основных компетенций: геймдизайна и разработки. Мне запомнился тезис о том, что нужно думать не только как программист (C#, Git), но и как дизайнер (баланс, руководство игроком, окружение). Это заставляет меня задуматься о необходимости развивать и «художественную» сторону мышления, изучать основы композиции и психологии восприятия, а не только чистый код.
4. Перспективы применения в образовании.
Меня особенно впечатлил блок про образовательные проекты. Идея создания интерактивных лабораторных работ и виртуальных стендов с помощью Unity кажется крайне перспективной. Это современный и engaging способ обучения, который может сделать сложные темы более наглядными и доступными. Возникает желание попробовать себя в роли создателя такого образовательного контента в будущем.



Практическая часть (Описание реализации)
•	Средства разработки: Укажите используемое программное обеспечение (Unity 2022.3.x, язык C#).
•	Описание сцены:
o	На сцене расположены: источник луча (Laser), представленный в виде тонкого цилиндра; набор плоских объектов-зеркал (Mirror) с настроенным глянцевым материалом; мишень (Target); окружающие стены для ограничения области симуляции.
 
Рисунок 1 Сцена в Unity
«В каждом кадре создается массив для хранения точек луча. С помощью цикла и функции Physics.Raycast луч испускается из текущей позиции. При попадании в коллайдер точка попадания фиксируется. Если объект имеет тег "Mirror", направление луча пересчитывается по формуле отражения, и луч испускается заново из новой точки. Цикл повторяется до достижения лимита отражений или пока луч не попадет в не-зеркальный объект. Полученный массив точек передается в компонент Line Renderer для визуализации.»
using UnityEngine;

public class LaserBeam : MonoBehaviour
{
    public int maxReflections = 10; // Максимальное число отражений
    public float maxLaserDistance = 100f; // Максимальная дальность луча

    private LineRenderer lineRenderer; // Компонент для рисования линии

    void Start()
    {
        // Получаем компонент LineRenderer или добавляем его, если его нет
        lineRenderer = GetComponent<LineRenderer>();
        if (lineRenderer == null)
        {
            lineRenderer = gameObject.AddComponent<LineRenderer>();
        }

        // Настраиваем внешний вид луча
        lineRenderer.startWidth = 0.05f;
        lineRenderer.endWidth = 0.05f;
        lineRenderer.material = Resources.Load<Material>("Materials/RedLaser"); // Убедись, что материал лежит в папке Resources/Materials/
        // Или просто назначьте материал через Inspector, перетащив его на компонент LineRenderer
    }

    void Update()
    {
        // Создаем массив точек для линии. Размер = число отражений + 2 (начальная точка и конец)
        Vector3[] points = new Vector3[maxReflections + 2];
        points[0] = transform.position; // Начало луча - позиция самого объекта Laser

        Vector3 currentDirection = transform.forward; // Начальное направление луча (вперед от объекта)
        Vector3 currentPosition = transform.position; // Начальная позиция для "пускания" луча

        int reflectionCount = 0;

        // Запускаем луч с помощью Raycast
        RaycastHit hit; // Переменная, которая хранит информацию о попадании

        for (int i = 0; i <= maxReflections; i++)
        {
            // Пускаем луч из currentPosition в направлении currentDirection
            if (Physics.Raycast(currentPosition, currentDirection, out hit, maxLaserDistance))
            {
                reflectionCount++; // Увеличиваем счетчик отражений
                points[i + 1] = hit.point; // Записываем точку попадания

                // Если луч попал во что-то, что НЕ является зеркалом, выходим из цикла
                if (!hit.collider.CompareTag("Mirror"))
                {
                    reflectionCount = i + 1; // Фиксируем финальное количество точек
                    break;
                }

                // Если попали в зеркало, рассчитываем новое направление и позицию для продолжения луча
                currentDirection = Vector3.Reflect(currentDirection, hit.normal);
                currentPosition = hit.point + currentDirection * 0.01f; // Слегка сдвигаемся от точки столкновения, чтобы не попасть в себя
            }
            else
            {
                // Если луч ни во что не попал, рисуем его в направлении на максимальную дистанцию
                points[i + 1] = currentPosition + currentDirection * maxLaserDistance;
                reflectionCount = i + 1;
                break;
            }
        }

        // Передаем массив точек в LineRenderer, но только нужное количество (reflectionCount + 1)
        lineRenderer.positionCount = reflectionCount + 1;
        lineRenderer.SetPositions(points);
    }
}

 Результаты работы.
Симуляция является интерактивной. Пользователь может в реальном времени перемещать и вращать зеркала в окне редактора Unity (или через UI-кнопки, если вы их сделали), наблюдая за мгновенным изменением траектории луча. Это наглядно демонстрирует зависимость угла отражения от угла падения.
Заключение и выводы
 В рамках данной работы была успешно разработана интерактивная симуляция, демонстрирующая закон отражения света. Основная цель достигнута.


Ссылка на гетхаб:
https://github.com/Porosh04ek/LightLaser
